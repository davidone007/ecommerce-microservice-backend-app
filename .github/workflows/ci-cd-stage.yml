name: CI - CD - Stage build ( Integration tests + K8s deploy + E2E tests )

permissions:
  contents: write
  packages: write
  id-token: write

on:
  push:
    branches: [stage, "ops/feat/*"]
  pull_request:
    branches: [stage, "ops/feat/*"]

jobs:
  maven-build:
    name: Build (Maven)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Build with Maven (compile + unit tests only)
        run: |
          chmod +x ./mvnw
          # Run only unit tests at this stage
          # Integration tests will run after infrastructure is deployed
          # Pattern: *ServiceImplTest for unit tests
          ./mvnw -B -T 1C verify \
            -Dtest="*ServiceImplTest" \
            -DfailIfNoTests=false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Get AKS Credentials
        run: az aks get-credentials --resource-group ecommerce-rg-stage --name ecommerce-aks-stage --overwrite-existing

      - name: Port-forward SonarQube
        run: |
          # Start port-forward in background
          kubectl port-forward svc/sonarqube-sonarqube 9000:9000 -n sonarqube &
          # Wait for connection to be ready
          sleep 5
          echo "SonarQube port-forward established on localhost:9000"

      - name: SonarQube analysis
        env:
          SONAR_HOST_URL: "http://localhost:9000"
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          if [ -z "$SONAR_TOKEN" ]; then
            echo "Skipping SonarQube analysis: SONAR_TOKEN not set as secret"
            exit 0
          fi

          chmod +x ./mvnw
          ./mvnw -B -DskipTests=true sonar:sonar \
          -Dsonar.host.url="$SONAR_HOST_URL" \
          -Dsonar.login="$SONAR_TOKEN" \
          -Dsonar.projectKey="ecommerce" \
          -Dsonar.projectName="ecommerce" \
          -Dsonar.coverage.jacoco.xmlReportPaths="**/target/site/jacoco/jacoco.xml,**/target/site/jacoco-aggregate/jacoco.xml"

      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            **/target/surefire-reports/*.xml
          retention-days: 3

      - name: Upload build workspace
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: |
            .
            !.git
          retention-days: 1

  docker-build:
    name: Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: maven-build
    strategy:
      fail-fast: false
      matrix:
        service:
          [
            api-gateway,
            cloud-config,
            favourite-service,
            order-service,
            payment-service,
            product-service,
            proxy-client,
            service-discovery,
            shipping-service,
            user-service,
          ]

    steps:
      - name: Download workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: Check if Dockerfile exists
        id: check
        run: |
          if [ -f "${{ matrix.service }}/Dockerfile" ]; then 
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else 
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set up Docker Buildx
        if: steps.check.outputs.exists == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        if: steps.check.outputs.exists == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        if: steps.check.outputs.exists == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/${{ matrix.service }}
          tags: |
            type=raw,value=stage
            type=sha,prefix=,format=long

      - name: Build and push
        if: steps.check.outputs.exists == 'true' && github.event_name == 'push' && (github.ref == 'refs/heads/stage' || startsWith(github.ref, 'refs/heads/ops/feat/'))
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build locally if push fails (for testing)
        if: steps.check.outputs.exists == 'true' && failure()
        run: |
          echo "‚ö†Ô∏è  GHCR push failed. Building image locally for testing..."
          docker build -f ${{ matrix.service }}/Dockerfile -t ${{ matrix.service }}:stage .

      - name: Set build tag output for K8s deployment
        if: steps.check.outputs.exists == 'true'
        id: build-tag
        run: |
          echo "tag=stage" >> "$GITHUB_OUTPUT"

  kubernetes-deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [docker-build, infrastructure-deploy]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/stage' || startsWith(github.ref, 'refs/heads/ops/feat/'))
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ecommerce-rg-stage
          cluster-name: ecommerce-aks-stage

      - name: Restart Deployments to pick up new image
        run: |
          echo "üöÄ Restarting deployments in stage namespace to pull new images..."
          kubectl rollout restart deployment -n stage
          
          echo "Waiting for rollouts to complete (timeout: 10 minutes)..."
          
          # Array of deployments to monitor
          declare -a DEPLOYMENTS=(
            "api-gateway-container"
            "product-service-container"
            "user-service-container"
            "order-service-container"
            "payment-service-container"
            "shipping-service-container"
            "favourite-service-container"
            "proxy-client-container"
            "service-discovery-container"
            "cloud-config-container"
            "zipkin-container"
          )
          
          # Wait for each deployment with extended timeout
          for deployment in "${DEPLOYMENTS[@]}"; do
            echo "‚è≥ Waiting for $deployment..."
            kubectl rollout status deployment/$deployment -n stage --timeout=10m || {
              echo "‚ö†Ô∏è  $deployment timed out or failed, checking status..."
              kubectl describe deployment/$deployment -n stage | tail -20
              kubectl get pods -n stage -l "io.kompose.service=$deployment" -o wide
              continue  # Don't stop, try the next one
            }
          done
          
          echo "‚úÖ Deployment restart completed"

      - name: Debug Deployment Status (if rollout failed)
        if: failure()
        run: |
          echo "‚ùå Rollout failed. Debugging..."
          echo ""
          echo "1. Pod status:"
          kubectl get pods -n stage -o wide
          echo ""
          echo "2. Pod events:"
          kubectl get events -n stage --sort-by='.lastTimestamp'
          echo ""
          echo "3. Describe failing pods:"
          kubectl get pods -n stage | grep -E "Pending|ImagePull|CrashLoop|Error" | awk '{print $1}' | while read pod; do
            echo "--- Pod: $pod ---"
            kubectl describe pod/$pod -n stage | tail -30
          done
          echo ""
          echo "4. Node resources:"
          kubectl top nodes
          kubectl top pods -n stage --sort-by=memory

      - name: Verify deployment
        run: |
          echo "üìã Kubernetes deployment status:"
          kubectl get deployments -n stage
          echo ""
          kubectl get services -n stage
          echo ""
          kubectl get pods -n stage

  integration-tests:
    name: Run Integration Tests
    runs-on: ubuntu-latest
    needs: kubernetes-deploy
    if: github.event_name == 'push' && (github.ref == 'refs/heads/stage' || startsWith(github.ref, 'refs/heads/ops/feat/'))
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "11"

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ecommerce-rg-stage
          cluster-name: ecommerce-aks-stage

      - name: Verify Pods and Services are Ready
        run: |
          echo "üîç Verifying pods and services are ready before port-forwarding..."
          
          declare -a SERVICES=(
            "product-service-container"
            "user-service-container"
            "shipping-service-container"
            "order-service-container"
            "payment-service-container"
            "favourite-service-container"
          )
          
          # Wait for pods to be ready
          echo "‚è≥ Waiting for pods to be ready..."
          for service in "${SERVICES[@]}"; do
            echo "Checking $service..."
            
            # Get deployment name (usually service name without -container)
            deployment="$service"
            
            # Wait for deployment rollout to complete
            echo "  Waiting for deployment/$deployment to be ready..."
            kubectl rollout status deployment/$deployment -n stage --timeout=5m || {
              echo "‚ö†Ô∏è  Deployment $deployment not ready, checking status..."
              kubectl get pods -n stage -l "io.kompose.service=$deployment" -o wide
              kubectl describe deployment/$deployment -n stage | tail -10
            }
            
            # Verify service has endpoints
            echo "  Verifying service/$service has endpoints..."
            for i in {1..30}; do
              ENDPOINTS=$(kubectl get endpoints $service -n stage -o jsonpath='{.subsets[*].addresses[*].ip}' 2>/dev/null || echo "")
              if [ -n "$ENDPOINTS" ]; then
                echo "  ‚úÖ Service $service has endpoints: $ENDPOINTS"
                break
              else
                if [ $i -eq 30 ]; then
                  echo "  ‚ùå Service $service has no endpoints after 30 attempts"
                  kubectl get endpoints $service -n stage
                  exit 1
                fi
                echo "  ‚è≥ Waiting for endpoints... ($i/30)"
                sleep 2
              fi
            done
          done
          
          echo "‚úÖ All pods and services are ready"

      - name: Port Forward Services
        run: |
          echo "üöÄ Starting port-forwards for all services..."
          
          # Function to start port-forward with logging and backgrounding
          start_pf() {
            local service=$1
            local port=$2
            local logfile="/tmp/${service}.log"
            echo "Starting port-forward for $service on port $port (log: $logfile)..."
            
            # Kill any existing port-forward for this service/port
            pkill -f "kubectl port-forward.*$service.*$port" || true
            sleep 1
            
            # Start port-forward in background
            nohup kubectl port-forward svc/$service $port:$port -n stage > "$logfile" 2>&1 &
            local pid=$!
            echo "PID: $pid"
            
            # Wait a bit for port-forward to establish
            sleep 3
            
            # Verify process is running
            if ! ps -p $pid > /dev/null 2>&1; then
              echo "‚ùå Port-forward for $service failed immediately. Log content:"
              cat "$logfile" || echo "Log file not found"
              return 1
            fi
            
            # Verify port is actually listening
            for i in {1..10}; do
              if timeout 1 bash -c "echo > /dev/tcp/localhost/$port" 2>/dev/null || \
                 netstat -tuln 2>/dev/null | grep -q ":$port.*LISTEN" || \
                 ss -tuln 2>/dev/null | grep -q ":$port.*LISTEN"; then
                echo "‚úÖ Port-forward for $service is listening on port $port (PID $pid)"
                return 0
              fi
              if [ $i -eq 10 ]; then
                echo "‚ö†Ô∏è  Port $port not listening after 10 attempts, but process is running"
                echo "Log content:"
                cat "$logfile" || echo "Log file not found"
                return 0  # Continue anyway, might work
              fi
              sleep 1
            done
          }

          start_pf "product-service-container" 8500
          start_pf "user-service-container" 8700
          start_pf "shipping-service-container" 8600
          start_pf "order-service-container" 8300
          start_pf "payment-service-container" 8400
          start_pf "favourite-service-container" 8800
          
          echo "‚è≥ Waiting 10s for connections to fully stabilize..."
          sleep 10
          
          echo "üîç Verifying port-forwards are active..."
          netstat -tuln 2>/dev/null | grep -E ":(8500|8700|8600|8300|8400|8800)" || \
          ss -tuln 2>/dev/null | grep -E ":(8500|8700|8600|8300|8400|8800)" || \
          echo "‚ö†Ô∏è  netstat/ss not available or ports not visible"
          
          # Check port-forward processes
          echo "üìã Port-forward processes:"
          ps aux | grep "kubectl port-forward" | grep -v grep || echo "No port-forward processes found"
          
          echo "‚úÖ Port-forward setup complete"

      - name: Wait for services
        run: |
          echo "‚è≥ Waiting for services to be ready via port-forward..."
          SECONDS_WAITED=0
          TIMEOUT=300

          # Direct service endpoints (bypassing API Gateway)
          declare -a ENDPOINTS=(
            "http://localhost:8500/product-service/api/products"
            "http://localhost:8700/user-service/api/users"
            "http://localhost:8600/shipping-service/api/shippings"
            "http://localhost:8800/favourite-service/api/favourites"
            "http://localhost:8400/payment-service/api/payments"
          )
          
          # Store PIDs of port-forwards for debugging
          declare -A SERVICE_PORTS=(
            ["product-service-container"]="8500"
            ["user-service-container"]="8700"
            ["shipping-service-container"]="8600"
            ["payment-service-container"]="8400"
            ["favourite-service-container"]="8800"
          )

          while [ $SECONDS_WAITED -lt $TIMEOUT ]; do
            ALL_READY=true
            READY_COUNT=0
            
            for endpoint in "${ENDPOINTS[@]}"; do
              # Try with a longer timeout
              STATUS=$(curl -s --max-time 5 --connect-timeout 3 -o /dev/null -w "%{http_code}" "$endpoint" 2>/dev/null || echo "000")
              
              if [ "$STATUS" = "200" ] || [ "$STATUS" = "404" ] || [ "$STATUS" = "401" ] || [ "$STATUS" = "403" ]; then
                READY_COUNT=$((READY_COUNT + 1))
                echo "‚úÖ $endpoint (HTTP $STATUS)"
              else
                ALL_READY=false
                # Extract port from endpoint for debugging
                PORT=$(echo "$endpoint" | grep -oP ':\K[0-9]+' | head -1)
                echo "‚è≥ $endpoint (HTTP $STATUS) - port $PORT"
              fi
            done
            
            echo "[$SECONDS_WAITED s] Ready endpoints: $READY_COUNT/${#ENDPOINTS[@]}"

            if [ "$ALL_READY" = true ]; then
              echo "‚úÖ All services are ready"
              exit 0
            fi
            
            # Every 30 seconds, check port-forward status
            if [ $((SECONDS_WAITED % 30)) -eq 0 ] && [ $SECONDS_WAITED -gt 0 ]; then
              echo "üîç Checking port-forward status..."
              for service in "${!SERVICE_PORTS[@]}"; do
                port="${SERVICE_PORTS[$service]}"
                if pgrep -f "kubectl port-forward.*$service.*$port" > /dev/null; then
                  echo "  ‚úÖ Port-forward for $service:$port is running"
                else
                  echo "  ‚ùå Port-forward for $service:$port is NOT running!"
                  echo "  Checking log:"
                  cat "/tmp/${service}.log" 2>/dev/null || echo "    Log file not found"
                fi
              done
            fi
            
            sleep 5
            SECONDS_WAITED=$((SECONDS_WAITED+5))
          done

          echo "‚ö†Ô∏è  Timeout reached after ${TIMEOUT}s. Diagnostic information:"
          echo ""
          
          echo "üìã Final endpoint status:"
          for endpoint in "${ENDPOINTS[@]}"; do
            STATUS=$(curl -s --max-time 5 --connect-timeout 3 -o /dev/null -w "%{http_code}" "$endpoint" 2>/dev/null || echo "000")
            ERROR=$(curl -s --max-time 5 --connect-timeout 3 "$endpoint" 2>&1 | head -1 || echo "Connection failed")
            if [ "$STATUS" = "200" ] || [ "$STATUS" = "404" ] || [ "$STATUS" = "401" ] || [ "$STATUS" = "403" ]; then
              echo "‚úÖ $endpoint (HTTP $STATUS)"
            else
              echo "‚ùå $endpoint (HTTP $STATUS) - Error: $ERROR"
            fi
          done
          
          echo ""
          echo "üîç Port-forward process status:"
          ps aux | grep "kubectl port-forward" | grep -v grep || echo "No port-forward processes running!"
          
          echo ""
          echo "üîç Port-forward logs:"
          for service in "${!SERVICE_PORTS[@]}"; do
            echo "--- Log for $service ---"
            cat "/tmp/${service}.log" 2>/dev/null | tail -20 || echo "Log file not found"
            echo ""
          done
          
          echo ""
          echo "üîç Checking Kubernetes service endpoints:"
          for service in "${!SERVICE_PORTS[@]}"; do
            echo "Service: $service"
            kubectl get endpoints $service -n stage -o wide || echo "  Failed to get endpoints"
            echo ""
          done
          
          echo ""
          echo "üîç Checking pod status:"
          kubectl get pods -n stage -o wide | head -20
          
          # Don't fail here, let the integration tests run and fail if needed
          echo ""
          echo "‚ö†Ô∏è  Some services may not be ready, but continuing with tests..."

      - name: Run Integration Tests
        run: |
          echo "Running integration tests..."
          chmod +x ./mvnw
          ./mvnw -B verify -DskipTests=false -Dtest="*IntegrationTest" || {
            echo "Integration tests failed. Dumping logs..."
            kubectl logs -n stage -l "app=integration-tests" --tail=100
            exit 1
          }

      - name: Verify database seeding
        run: |
          echo "Verifying database seeding..."
          # Add your verification commands here, e.g., checking if certain records exist
          # Example: curl -s http://localhost:8500/product-service/api/products | jq '. | length'
