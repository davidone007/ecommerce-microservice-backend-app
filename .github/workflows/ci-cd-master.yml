name: CI - CD - Master build (Release + K8s deploy + Smoke tests)

permissions:
  contents: write
  packages: write
  id-token: write

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

jobs:
  maven-build:
    name: Build (Maven)
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "11"

      - name: Build with Maven (compile + unit tests only)
        run: |
          chmod +x ./mvnw
          # Run only unit tests at this stage
          # System tests will run after infrastructure is deployed
          # Pattern: *ServiceImplTest for unit tests
          ./mvnw -B -T 1C verify \
            -Dtest="*ServiceImplTest" \
            -DfailIfNoTests=false

      - name: Ensure SonarQube available (start local if missing)
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          if [ -z "$SONAR_HOST_URL" ] || [ -z "$SONAR_TOKEN" ]; then
            echo "SONAR_HOST_URL or SONAR_TOKEN not set; skipping Sonar availability check/startup"
            exit 0
          fi

          echo "Checking SonarQube at $SONAR_HOST_URL"
          if curl -sSf --max-time 5 "$SONAR_HOST_URL" >/dev/null 2>&1; then
            echo "SonarQube is reachable"
            exit 0
          fi

          echo "SonarQube not reachable. Attempting to start local Sonar using docker-compose.sonar.yml"
          if command -v docker >/dev/null 2>&1; then
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            else
              DOCKER_COMPOSE_CMD="docker compose"
            fi
            echo "Using: $DOCKER_COMPOSE_CMD"
            $DOCKER_COMPOSE_CMD -f docker-compose.sonar.yml up -d
          else
            echo "Docker not available on runner; cannot start local Sonar. Proceeding and letting Sonar analysis step handle unreachable host."
            exit 0
          fi

          SECONDS_WAITED=0
          until curl -sSf --max-time 5 "$SONAR_HOST_URL" >/dev/null 2>&1 || [ $SECONDS_WAITED -ge 180 ]; do
            sleep 5
            SECONDS_WAITED=$((SECONDS_WAITED+5))
            echo "Waiting for SonarQube... ($SECONDS_WAITED s)"
          done

          if curl -sSf --max-time 5 "$SONAR_HOST_URL" >/dev/null 2>&1; then
            echo "SonarQube is up after startup"
          else
            echo "Timed out waiting for SonarQube to start. Proceeding and letting Sonar analysis step run (it may fail)."
          fi

      - name: SonarQube analysis
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          if [ -z "$SONAR_HOST_URL" ] || [ -z "$SONAR_TOKEN" ]; then
            echo "Skipping SonarQube analysis: SONAR_HOST_URL or SONAR_TOKEN not set as secrets"
            exit 0
          fi

          chmod +x ./mvnw
          ./mvnw -B -DskipTests=true sonar:sonar \
          -Dsonar.host.url="$SONAR_HOST_URL" \
          -Dsonar.login="$SONAR_TOKEN" \
          -Dsonar.projectKey="ecommerce" \
          -Dsonar.projectName="ecommerce" \
          -Dsonar.coverage.jacoco.xmlReportPaths="**/target/site/jacoco/jacoco.xml,**/target/site/jacoco-aggregate/jacoco.xml"

      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            **/target/surefire-reports/*.xml
          retention-days: 7

      - name: Upload build workspace
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: |
            .
            !.git
          retention-days: 1

  docker-build:
    name: Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: maven-build
    strategy:
      fail-fast: false
      matrix:
        service:
          [
            api-gateway,
            cloud-config,
            favourite-service,
            order-service,
            payment-service,
            product-service,
            proxy-client,
            service-discovery,
            shipping-service,
            user-service,
          ]

    steps:
      - name: Download workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: Check if Dockerfile exists
        id: check
        run: |
          if [ -f "${{ matrix.service }}/Dockerfile" ]; then 
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else 
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set up Docker Buildx
        if: steps.check.outputs.exists == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        if: steps.check.outputs.exists == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        if: steps.check.outputs.exists == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/${{ matrix.service }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest
            type=sha,prefix=,format=long

      - name: Build and push
        if: steps.check.outputs.exists == 'true' && github.event_name == 'push' && github.ref == 'refs/heads/master'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build locally if push fails (for testing)
        if: steps.check.outputs.exists == 'true' && failure()
        run: |
          echo "‚ö†Ô∏è  GHCR push failed. Building image locally for testing..."
          docker build -f ${{ matrix.service }}/Dockerfile -t ${{ matrix.service }}:latest .

      - name: Set build tag output for K8s deployment
        if: steps.check.outputs.exists == 'true'
        id: build-tag
        run: |
          echo "tag=latest" >> "$GITHUB_OUTPUT"

  kubernetes-deploy:
    name: Deploy to Kubernetes (Production)
    runs-on: self-hosted
    needs: docker-build
    environment: production
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    steps:
          - name: Checkout
            uses: actions/checkout@v4

          - name: Azure Login
            uses: azure/login@v1
            with:
              creds: ${{ secrets.AZURE_CREDENTIALS }}

          - name: Set AKS Context
            uses: azure/aks-set-context@v3
            with:
              resource-group: ecommerce-rg-stage
              cluster-name: ecommerce-aks-stage

          - name: Update image tags in deployments (selective)
            run: |
              echo "üöÄ Updating only application service deployments..."
              
              # Lista ESPEC√çFICA de tus servicios de aplicaci√≥n (NO infraestructura)
              declare -a APP_DEPLOYMENTS=(
                "api-gateway-container"
                "product-service-container"
                "user-service-container"
                "order-service-container"
                "payment-service-container"
                "shipping-service-container"
                "favourite-service-container"
                "proxy-client-container"
                "service-discovery-container"
                "cloud-config-container"
              )
              
              IMAGE_TAG="stage"
              REGISTRY="ghcr.io/${{ github.repository_owner }}"
              
              # Actualizar cada deployment individualmente
              for deployment in "${APP_DEPLOYMENTS[@]}"; do
                # Extraer el nombre del servicio (sin el sufijo -container)
                SERVICE_NAME="${deployment%-container}"
                
                echo "üì¶ Updating $deployment with image tag: $IMAGE_TAG"
                
                # Verificar si el deployment existe
                if kubectl get deployment "$deployment" -n stage &> /dev/null; then
                  # Actualizar la imagen del contenedor
                  kubectl set image deployment/"$deployment" \
                    "$deployment=$REGISTRY/$SERVICE_NAME:$IMAGE_TAG" \
                    -n stage
                  
                  echo "‚úÖ Updated $deployment"
                else
                  echo "‚ö†Ô∏è  Deployment $deployment not found, skipping..."
                fi
              done

          - name: Wait for rollouts with proper timeout
            run: |
              echo "‚è≥ Waiting for rollouts to complete..."
              
              declare -a APP_DEPLOYMENTS=(
                "api-gateway-container"
                "product-service-container"
                "user-service-container"
                "order-service-container"
                "payment-service-container"
                "shipping-service-container"
                "favourite-service-container"
                "proxy-client-container"
                "service-discovery-container"
                "cloud-config-container"
              )
              
              FAILED_DEPLOYMENTS=()
              
              for deployment in "${APP_DEPLOYMENTS[@]}"; do
                if kubectl get deployment "$deployment" -n stage &> /dev/null; then
                  echo "‚è≥ Waiting for $deployment rollout..."
                  
                  if kubectl rollout status deployment/"$deployment" -n stage --timeout=10m; then
                    echo "‚úÖ $deployment rolled out successfully"
                  else
                    echo "‚ùå $deployment rollout failed or timed out"
                    FAILED_DEPLOYMENTS+=("$deployment")
                    
                    # Debug information
                    echo "--- Debugging $deployment ---"
                    kubectl describe deployment/"$deployment" -n stage | tail -30
                    kubectl get pods -n stage -l "io.kompose.service=$deployment" -o wide
                  fi
                fi
              done
              
              # Check if any deployments failed
              if [ ${#FAILED_DEPLOYMENTS[@]} -gt 0 ]; then
                echo ""
                echo "‚ùå The following deployments failed:"
                printf '%s\n' "${FAILED_DEPLOYMENTS[@]}"
                exit 1
              fi
              
              echo ""
              echo "‚úÖ All application deployments completed successfully"

          - name: Verify services are accessible
            run: |
              echo "üîç Verifying service endpoints..."
              
              # Wait a bit for services to stabilize
              sleep 30
              
              # Get API Gateway External IP
              EXTERNAL_IP=$(kubectl get svc api-gateway-container -n stage -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              
              if [ -z "$EXTERNAL_IP" ]; then
                echo "‚ö†Ô∏è  Could not get External IP, checking service status..."
                kubectl get svc -n stage
                exit 1
              fi
              
              echo "API Gateway IP: $EXTERNAL_IP"
              
              # Quick health check
              HEALTH_URL="http://$EXTERNAL_IP:8080/actuator/health"
              echo "Checking health endpoint: $HEALTH_URL"
              
              RETRIES=0
              MAX_RETRIES=10
              
              while [ $RETRIES -lt $MAX_RETRIES ]; do
                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" 2>/dev/null || echo "000")
                
                if [ "$HTTP_CODE" = "200" ]; then
                  echo "‚úÖ API Gateway is healthy (HTTP $HTTP_CODE)"
                  break
                else
                  echo "‚è≥ Waiting for API Gateway... (HTTP $HTTP_CODE) - Retry $((RETRIES+1))/$MAX_RETRIES"
                  sleep 10
                  RETRIES=$((RETRIES+1))
                fi
              done
              
              if [ $RETRIES -eq $MAX_RETRIES ]; then
                echo "‚ùå API Gateway health check failed after $MAX_RETRIES retries"
                exit 1
              fi

          - name: Debug Deployment Status (if rollout failed)
            if: failure()
            run: |
              echo "‚ùå Deployment failed. Debugging..."
              echo ""
              echo "1. All deployments:"
              kubectl get deployments -n stage -o wide
              echo ""
              echo "2. Pod status:"
              kubectl get pods -n stage -o wide
              echo ""
              echo "3. Recent events:"
              kubectl get events -n stage --sort-by='.lastTimestamp' | tail -50
              echo ""
              echo "4. Services status:"
              kubectl get services -n stage
              echo ""
              echo "5. Failing pods details:"
              kubectl get pods -n stage | grep -E "Pending|ImagePull|CrashLoop|Error|0/" | awk '{print $1}' | while read pod; do
                echo "--- Pod: $pod ---"
                kubectl describe pod/"$pod" -n stage | tail -50
                echo ""
                kubectl logs "$pod" -n stage --tail=50 2>/dev/null || echo "No logs available"
                echo ""
              done

          - name: Verify final deployment state
            run: |
              echo "üìã Final Kubernetes state:"
              echo ""
              echo "Deployments:"
              kubectl get deployments -n stage
              echo ""
              echo "Services:"
              kubectl get services -n stage
              echo ""
              echo "Pods:"
              kubectl get pods -n stage -o wide

  integration-tests:
    name: Run Integration Tests
    runs-on: self-hosted
    needs: kubernetes-deploy
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "11"

      - name: Wait for API Gateway to be ready
        run: |
          echo "Waiting for services to be ready..."
          SECONDS_WAITED=0
          TIMEOUT=300

          # Array of service endpoints to check
          declare -a ENDPOINTS=(
            "http://localhost:8080/app/api/products"
            "http://localhost:8600/shipping-service/api/shippings"
            "http://localhost:8700/user-service/api/users"
            "http://localhost:8500/product-service/api/products"
            "http://localhost:8800/favourite-service/api/favourites"
            "http://localhost:8400/payment-service/api/payments"
          )

          # Check all endpoints until they are ready or timeout
          while [ $SECONDS_WAITED -lt $TIMEOUT ]; do
            ALL_READY=true
            for endpoint in "${ENDPOINTS[@]}"; do
              if ! curl -sSf "$endpoint" >/dev/null 2>&1; then
                ALL_READY=false
                break
              fi
            done
            
            if [ "$ALL_READY" = true ]; then
              echo "‚úÖ All services are ready"
              exit 0
            fi
            
            sleep 5
            SECONDS_WAITED=$((SECONDS_WAITED+5))
            echo "Waiting for services... ($SECONDS_WAITED s / $TIMEOUT s)"
          done

          echo "‚ö†Ô∏è  Service health check timed out after $TIMEOUT seconds"
          echo "Checking pod status..."
          kubectl get pods
          exit 1

      - name: Run Integration Tests against deployed services
        run: |
          chmod +x ./mvnw
          echo "üß™ Running integration tests (*IntegrationTest pattern) against live services..."
          echo "Target API: http://localhost:8080/app/api"
          echo ""

          ./mvnw -B -T 1C verify \
            -Dtest="*IntegrationTest" \
            -DfailIfNoTests=false

      - name: Upload integration test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: |
            **/target/surefire-reports/*IntegrationTest*.xml
          retention-days: 7

      - name: Check test results
        if: always()
        run: |
          echo "üìä Integration Test Summary:"
          echo ""
          # Count test results
          TOTAL_TESTS=$(find . -name "*IntegrationTest*.xml" -exec grep -c "<testcase" {} + 2>/dev/null | awk '{sum+=$1} END {print sum}')
          FAILURES=$(find . -name "*IntegrationTest*.xml" -exec grep -c "<failure" {} + 2>/dev/null | awk '{sum+=$1} END {print sum}')

          echo "Total tests executed: ${TOTAL_TESTS:-0}"
          echo "Failures: ${FAILURES:-0}"
          echo ""

          if [ "$FAILURES" -gt 0 ]; then
            echo "‚ö†Ô∏è  Some integration tests failed. Check artifacts for details."
          else
            echo "‚úÖ All integration tests passed"
          fi

  smoke-tests:
    name: Run Smoke Tests
    runs-on: self-hosted
    needs: integration-tests
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug - Check services status
        run: |
          echo "üìã Debugging: Checking service ports..."
          echo ""
          echo "Checking if ports are listening:"
          for port in 8080 8300 8400 8500 8600 8700 8800 9411; do
            if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
              echo "‚úÖ Port $port is listening"
            else
              echo "‚ùå Port $port is NOT listening"
            fi
          done
          echo ""
          echo "Kubernetes pods status:"
          kubectl get pods --no-headers 2>/dev/null || echo "kubectl not available"
          echo ""
          echo "Kubernetes services:"
          kubectl get svc --no-headers 2>/dev/null || echo "kubectl not available"

      - name: Wait for services with retry
        continue-on-error: true
        run: |
          echo "Waiting for services to be ready for smoke tests..."
          SECONDS_WAITED=0
          TIMEOUT=120
          RETRY_DELAY=5

          # Array of service endpoints to check
          declare -a ENDPOINTS=(
            "http://localhost:8080/app/api/products"
            "http://localhost:8600/shipping-service/api/shippings"
            "http://localhost:8700/user-service/api/users"
            "http://localhost:8500/product-service/api/products"
            "http://localhost:8800/favourite-service/api/favourites"
            "http://localhost:8400/payment-service/api/payments"
            "http://localhost:8300/order-service/api/orders"
          )

          # Check all endpoints until they are ready or timeout
          while [ $SECONDS_WAITED -lt $TIMEOUT ]; do
            ALL_READY=true
            READY_COUNT=0
            
            for endpoint in "${ENDPOINTS[@]}"; do
              if curl -sSf --max-time 3 "$endpoint" >/dev/null 2>&1; then
                READY_COUNT=$((READY_COUNT + 1))
              else
                ALL_READY=false
              fi
            done
            
            echo "[$SECONDS_WAITED s] Ready endpoints: $READY_COUNT/${#ENDPOINTS[@]}"
            
            if [ "$ALL_READY" = true ]; then
              echo "‚úÖ All services are ready for smoke tests"
              exit 0
            fi
            
            sleep $RETRY_DELAY
            SECONDS_WAITED=$((SECONDS_WAITED + RETRY_DELAY))
          done

          echo "‚ö†Ô∏è  Service health check timed out after $TIMEOUT seconds"
          echo "üìå Proceeding anyway with smoke tests (testing what's available)..."
          exit 0

      - name: Run Smoke Tests (Health Checks)
        run: |
          echo "üî• Running Smoke Tests..."
          echo ""

          # Create output directory for reports
          mkdir -p smoke-test-reports
          FAILED_TESTS=0
          PASSED_TESTS=0

          # Function to test an endpoint
          test_endpoint() {
            local test_num=$1
            local test_name=$2
            local endpoint=$3
            
            echo "$test_numÔ∏è‚É£  Testing $test_name..."
            if curl -sSf --max-time 5 "$endpoint" >/dev/null 2>&1; then
              echo "‚úÖ $test_name"
              echo "PASS: $test_name" >> smoke-test-reports/smoke-tests.log
              PASSED_TESTS=$((PASSED_TESTS + 1))
            else
              echo "‚ùå $test_name FAILED"
              echo "FAIL: $test_name" >> smoke-test-reports/smoke-tests.log
              FAILED_TESTS=$((FAILED_TESTS + 1))
            fi
          }

          # Test 1: API Gateway Health
          test_endpoint "1" "API Gateway - Products" "http://localhost:8080/app/api/products"

          # Test 2: Product Service Health
          test_endpoint "2" "Product Service" "http://localhost:8500/product-service/api/products"

          # Test 3: User Service Health
          test_endpoint "3" "User Service" "http://localhost:8700/user-service/api/users"

          # Test 4: Order Service Health
          test_endpoint "4" "Order Service" "http://localhost:8300/order-service/api/orders"

          # Test 5: Payment Service Health
          test_endpoint "5" "Payment Service" "http://localhost:8400/payment-service/api/payments"

          # Test 6: Shipping Service Health
          test_endpoint "6" "Shipping Service" "http://localhost:8600/shipping-service/api/shippings"

          # Test 7: Favourite Service Health
          test_endpoint "7" "Favourite Service" "http://localhost:8800/favourite-service/api/favourites"

          echo ""
          echo "üìä Smoke Test Results: $PASSED_TESTS passed, $FAILED_TESTS failed"

          # Exit with error if any test failed
          if [ $FAILED_TESTS -gt 0 ]; then
            echo "‚ö†Ô∏è  Some smoke tests failed!"
            exit 1
          else
            echo "‚úÖ All smoke tests passed!"
            exit 0
          fi

      - name: Upload smoke test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-reports
          path: smoke-test-reports/
          retention-days: 30

      - name: Smoke Test Summary
        if: always()
        run: |
          echo "üî• Smoke Test Summary:"
          echo ""
          if [ -f "smoke-test-reports/smoke-tests.log" ]; then
            TOTAL=$(wc -l < smoke-test-reports/smoke-tests.log)
            PASSED=$(grep -c "PASS:" smoke-test-reports/smoke-tests.log || true)
            FAILED=$(grep -c "FAIL:" smoke-test-reports/smoke-tests.log || true)
            
            echo "Total Tests: $TOTAL"
            echo "Passed: $PASSED"
            echo "Failed: $FAILED"
            echo ""
            echo "Details:"
            cat smoke-test-reports/smoke-tests.log
          else
            echo "No smoke test log found"
          fi

  generate-release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    needs: smoke-tests
    if: github.event_name == 'push' && github.ref == 'refs/heads/master' && success()
    outputs:
      release_version: ${{ steps.output_info.outputs.version }}
      changelog: ${{ steps.output_info.outputs.changelog }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate Semantic Version & Changelog
        id: version
        uses: mathieudutour/github-tag-action@v6.1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          release_branches: master
          tag_prefix: v
          dry_run: true
          default_bump: patch

      - name: Output Version & Changelog
        id: output_info
        run: |
          echo "version=${{ steps.version.outputs.new_version }}" >> "$GITHUB_OUTPUT"
          echo "changelog<<EOF" >> "$GITHUB_OUTPUT"
          echo "${{ steps.version.outputs.changelog }}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          # Save changelog to file
          echo "${{ steps.version.outputs.changelog }}" > CHANGELOG_TEMP.txt

      - name: Create GitHub Release
        if: github.event_name == 'push' && github.ref == 'refs/heads/master'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.output_info.outputs.version }}
          release_name: Release v${{ steps.output_info.outputs.version }}
          body: |
            # üöÄ Release v${{ steps.output_info.outputs.version }}

            ## üìù Changelog

            ${{ steps.output_info.outputs.changelog }}

            ## üì¶ Artifacts

            - Build Date: ${{ github.event.head_commit.timestamp }}
            - Commit: ${{ github.sha }}
            - Author: ${{ github.actor }}

            ## üîó Images

            Docker images for this release:
            - `ghcr.io/${{ github.repository_owner }}/api-gateway:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/product-service:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/user-service:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/order-service:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/payment-service:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/shipping-service:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/favourite-service:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/proxy-client:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/service-discovery:v${{ steps.version.outputs.version }}`
            - `ghcr.io/${{ github.repository_owner }}/cloud-config:v${{ steps.version.outputs.version }}`

            ## ‚úÖ Quality Gates Passed

            - Unit Tests: ‚úÖ
            - Code Quality (SonarQube): ‚úÖ
            - Container Build: ‚úÖ
            - Kubernetes Deployment: ‚úÖ
            - Integration Tests: ‚úÖ
            - Smoke Tests: ‚úÖ

          draft: false
          prerelease: false

      - name: Upload changelog as artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: CHANGELOG_TEMP.txt
          retention-days: 30

  post-deployment:
    name: Post Deployment Verification
    runs-on: self-hosted
    needs: generate-release-notes
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "üìä Post-Deployment Verification Report"
          echo ""
          echo "üü¢ Production Deployment Completed"
          echo ""
          echo "Services Status:"
          kubectl get deployments -o wide
          echo ""
          echo "Pods Status:"
          kubectl get pods -o wide
          echo ""
          echo "‚úÖ All deployment steps completed successfully"
          echo ""
          echo "üìå Release Notes and artifacts are available in GitHub Actions"

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    if: success()
    needs: [maven-build, docker-build, kubernetes-deploy, integration-tests, post-deployment, generate-release-notes]
    steps:
      - name: Send Email Notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "‚úÖ Production Release Success: ${{ github.repository }}"
          body: |
            The production release for ${{ github.repository }} has completed successfully! üöÄ
            
            Repository: ${{ github.repository }}
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}
            Branch: master
            
            Check the logs here: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          to: ${{ secrets.MAIL_TO }}
          from: GitHub Actions <${{ secrets.MAIL_USERNAME }}>
          secure: true

  notify-failure-or-cancel:
    name: Notify Failure or Cancellation
    runs-on: ubuntu-latest
    if: failure() || cancelled()
    needs: [maven-build, docker-build, kubernetes-deploy, integration-tests, post-deployment, generate-release-notes]
    steps:
      - name: Send Email Notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "‚ùå Production Release Failed or Cancelled: ${{ github.repository }}"
          body: |
            The production release for ${{ github.repository }} has failed or was cancelled.
            
            Repository: ${{ github.repository }}
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}
            Branch: master
            
            Check the logs here: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          to: ${{ secrets.MAIL_TO }}
          from: GitHub Actions <${{ secrets.MAIL_USERNAME }}>
          secure: true
